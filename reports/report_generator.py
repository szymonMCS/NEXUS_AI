# reports/report_generator.py
"""
Report generator for NEXUS AI Lite.
Generates Markdown and HTML reports from analysis results.
"""

from datetime import datetime
from typing import List, Dict, Any, Optional
from pathlib import Path
from dataclasses import dataclass


@dataclass
class RankedBet:
    """Structured bet for reports."""
    rank: int
    match_name: str
    league: str
    selection: str
    odds: float
    bookmaker: str
    edge: float
    quality_score: float
    stake_recommendation: str
    confidence: float
    reasoning: List[str]
    warnings: List[str] = None

    def __post_init__(self):
        if self.warnings is None:
            self.warnings = []


class ReportGenerator:
    """
    Generates reports in Markdown and HTML formats.
    """

    def __init__(self, output_dir: str = "outputs"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)

    def generate_markdown(
        self,
        bets: List[Dict[str, Any]],
        sport: str,
        date: str
    ) -> str:
        """
        Generate Markdown report.

        Args:
            bets: List of bet dictionaries
            sport: Sport name
            date: Analysis date

        Returns:
            Markdown content string
        """
        if not bets:
            return self._generate_no_bets_report(sport, date)

        lines = [
            f"# NEXUS AI - Prediction Report",
            f"",
            f"**Sport:** {sport.upper()}  ",
            f"**Date:** {date}  ",
            f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}",
            f"",
            f"---",
            f"",
            f"## TOP {len(bets)} VALUE BETS",
            f""
        ]

        rank_emoji = ["1.", "2.", "3.", "4.", "5."]

        for i, bet in enumerate(bets):
            emoji = rank_emoji[i] if i < 5 else f"{i+1}."

            # Handle both dict and RankedBet objects
            if isinstance(bet, dict):
                match_name = bet.get("match_name", bet.get("match", "Unknown"))
                league = bet.get("league", "Unknown")
                selection = bet.get("selection", "")
                odds = bet.get("odds", 0)
                bookmaker = bet.get("bookmaker", "")
                edge = bet.get("edge", 0)
                quality_score = bet.get("quality_score", 0)
                stake = bet.get("stake_recommendation", bet.get("stake", "1%"))
                confidence = bet.get("confidence", 0)
                reasoning = bet.get("reasoning", [])
                warnings = bet.get("warnings", [])
            else:
                match_name = bet.match_name
                league = bet.league
                selection = bet.selection
                odds = bet.odds
                bookmaker = bet.bookmaker
                edge = bet.edge
                quality_score = bet.quality_score
                stake = bet.stake_recommendation
                confidence = bet.confidence
                reasoning = bet.reasoning
                warnings = bet.warnings

            lines.extend([
                f"### {emoji} {match_name}",
                f"",
                f"**League:** {league}  ",
                f"**Selection:** {selection.upper()}  ",
                f"**Odds:** {odds:.2f} @ {bookmaker}  ",
                f"**Edge:** +{edge:.1%}  ",
                f"**Data Quality:** {quality_score:.0f}/100  ",
                f"**Confidence:** {confidence:.0%}  ",
                f"**Stake:** {stake}",
                f""
            ])

            if reasoning:
                lines.append("**Reasoning:**")
                for r in reasoning[:3]:
                    lines.append(f"> {r}")
                lines.append("")

            if warnings:
                lines.append("**Warnings:**")
                for w in warnings[:2]:
                    lines.append(f"- {w}")
                lines.append("")

            lines.extend(["---", ""])

        # Summary
        avg_edge = sum(
            (b.get("edge", 0) if isinstance(b, dict) else b.edge)
            for b in bets
        ) / len(bets)
        avg_quality = sum(
            (b.get("quality_score", 0) if isinstance(b, dict) else b.quality_score)
            for b in bets
        ) / len(bets)

        lines.extend([
            f"## Summary",
            f"",
            f"- **Value bets found:** {len(bets)}",
            f"- **Average edge:** {avg_edge:.1%}",
            f"- **Average data quality:** {avg_quality:.0f}/100",
            f"",
            f"---",
            f"",
            f"*Report generated by NEXUS AI Lite v2.0*"
        ])

        return "\n".join(lines)

    def _generate_no_bets_report(self, sport: str, date: str) -> str:
        """Generate report when no bets are found."""
        return f"""# NEXUS AI - Prediction Report

**Sport:** {sport.upper()}
**Date:** {date}
**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}

---

## No Value Bets Found

The system did not find any bets meeting quality and value criteria.

**Possible reasons:**
- Insufficient data quality from web sources
- No matches with positive edge
- Bookmaker odds are too efficient

**Recommendation:** Try again later or check a different sport.

---

*Report generated by NEXUS AI Lite v2.0*
"""

    def generate_html(
        self,
        bets: List[Dict[str, Any]],
        sport: str,
        date: str
    ) -> str:
        """
        Generate HTML report with styling.

        Args:
            bets: List of bet dictionaries
            sport: Sport name
            date: Analysis date

        Returns:
            HTML content string
        """
        if not bets:
            return self._generate_no_bets_html(sport, date)

        bet_cards = ""
        rank_colors = ["#FFD700", "#C0C0C0", "#CD7F32", "#666", "#666"]

        for i, bet in enumerate(bets):
            color = rank_colors[i] if i < 5 else "#666"

            if isinstance(bet, dict):
                match_name = bet.get("match_name", bet.get("match", "Unknown"))
                league = bet.get("league", "Unknown")
                selection = bet.get("selection", "")
                odds = bet.get("odds", 0)
                bookmaker = bet.get("bookmaker", "")
                edge = bet.get("edge", 0)
                quality_score = bet.get("quality_score", 0)
                stake = bet.get("stake_recommendation", bet.get("stake", "1%"))
            else:
                match_name = bet.match_name
                league = bet.league
                selection = bet.selection
                odds = bet.odds
                bookmaker = bet.bookmaker
                edge = bet.edge
                quality_score = bet.quality_score
                stake = bet.stake_recommendation

            bet_cards += f"""
            <div class="bet-card" style="border-left: 4px solid {color};">
                <div class="rank">#{i+1}</div>
                <h3>{match_name}</h3>
                <p class="league">{league}</p>
                <div class="stats">
                    <div class="stat">
                        <span class="label">Selection</span>
                        <span class="value">{selection.upper()}</span>
                    </div>
                    <div class="stat">
                        <span class="label">Odds</span>
                        <span class="value">{odds:.2f}</span>
                    </div>
                    <div class="stat">
                        <span class="label">Edge</span>
                        <span class="value edge">+{edge:.1%}</span>
                    </div>
                    <div class="stat">
                        <span class="label">Quality</span>
                        <span class="value">{quality_score:.0f}/100</span>
                    </div>
                </div>
                <div class="recommendation">
                    <strong>Stake:</strong> {stake} @ {bookmaker}
                </div>
            </div>
            """

        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS AI Report - {sport.upper()} {date}</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 2rem;
        }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        header {{
            text-align: center;
            margin-bottom: 3rem;
        }}
        h1 {{
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(90deg, #00d9ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }}
        .meta {{ color: #888; font-size: 0.9rem; }}
        .bets-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1.5rem;
        }}
        .bet-card {{
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 1.5rem;
            backdrop-filter: blur(10px);
        }}
        .rank {{
            font-size: 2rem;
            font-weight: bold;
            color: #00d9ff;
            margin-bottom: 0.5rem;
        }}
        .bet-card h3 {{
            font-size: 1.2rem;
            margin-bottom: 0.25rem;
        }}
        .league {{
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }}
        .stats {{
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }}
        .stat {{
            text-align: center;
        }}
        .stat .label {{
            display: block;
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
        }}
        .stat .value {{
            font-size: 1.25rem;
            font-weight: bold;
        }}
        .stat .value.edge {{
            color: #00ff88;
        }}
        .recommendation {{
            background: rgba(0,217,255,0.1);
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
        }}
        footer {{
            text-align: center;
            margin-top: 3rem;
            color: #666;
            font-size: 0.85rem;
        }}
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>NEXUS AI</h1>
            <p class="meta">{sport.upper()} | {date} | Generated {datetime.now().strftime('%H:%M')}</p>
        </header>

        <div class="bets-grid">
            {bet_cards}
        </div>

        <footer>
            <p>Report generated by NEXUS AI Lite v2.0</p>
        </footer>
    </div>
</body>
</html>
"""

    def _generate_no_bets_html(self, sport: str, date: str) -> str:
        """Generate HTML report when no bets are found."""
        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>NEXUS AI Report - No Bets</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #1a1a2e;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
        }}
        h1 {{ color: #ff6b6b; }}
    </style>
</head>
<body>
    <div>
        <h1>No Value Bets Found</h1>
        <p>{sport.upper()} | {date}</p>
        <p>Try again later or check a different sport.</p>
    </div>
</body>
</html>
"""

    def save_report(
        self,
        content: str,
        sport: str,
        date: str,
        format: str = "md"
    ) -> str:
        """
        Save report to file.

        Args:
            content: Report content
            sport: Sport name
            date: Analysis date
            format: "md" or "html"

        Returns:
            Path to saved file
        """
        filename = f"report_{date}_{sport}.{format}"
        filepath = self.output_dir / filename

        with open(filepath, "w", encoding="utf-8") as f:
            f.write(content)

        return str(filepath)
